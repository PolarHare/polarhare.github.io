---
layout: ru/blogs/239/2020/post
title:  "Метод двух указателей и бинарный поиск"
date:   2021-05-18 12:03:00 +0300
lang:   ru
categories: school239_105_2020_2021
---

Метод двух указателей
===

Рекомендуемые источники
-----

[Видеозапись А.С.Куликова про два указателя](https://www.youtube.com/watch?v=bLxoU5oCatY)

[Краткая теория про два указателя](https://informatics.mccme.ru/mod/resource/view.php?id=12716)

[Слияние двух отсортированных массивов и merge-sort](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)

Примеры задач
-----

 - [Задача про эльфов и оленей](https://informatics.mccme.ru/moodle/mod/statements/view3.php?id=347&chapterid=414)
 - [Задача про бинарную строку](https://codeforces.com/contest/165/problem/C)
 - [6 задач](http://server.179.ru/tasks/training/000793.html)
 
Бинарный поиск
===

Вводная
-----

Что если у вас есть некоторый набор данных, будь-то чисел или список имен и вы хотите быстро научиться отвечать на запрос "есть ли среди вашего набора такой-то элемент"?

В таком случае можно как в телефонном справочнике упорядочить все записи в порядке возрастания (или если речь идет про список имен - то в алфавитном порядке), и затем когда приходит запрос "есть ли X", то достаточно:

0) Пусть в массиве $$as[i]$$ содержится $$N$$ элементов в порядке возрастания и нужно найти элемент $$x$$.

1) Изначально ответ находится в диапазоне поиска с элемента под индексом $$left=0$$ до $$right=N-1$$ (т.е. весь массив).

2) Посмотрим в элемент в середине диапазоне поиска, т.е. на элемент по индексу $$medium=(left+right)/2$$.

3.1) Если элемент в середине меньше искомого (т.е. $$as[medium] \leq X$$), то продолжать искать надо в правой половине, т.е. левая граница сдвинулась в центр, т.е. теперь $$left=medium$$.

3.2) Иначе продолжать искать надо в левой половине, т.е. правая граница сдвинулась в центр, т.е. теперь $$right=medium$$.

4) Если ответ еще не найден - продолжаем смотря на элемент в середине диапазона постепенно его сужать, т.е. вновь продолжаем шаги **2-4**.

Определения
-----

```Правосторонний поиск``` - поиск такого наибольшего (т.е. самого правого) индекса $$i$$ что $$as[i] \leq x$$, где $$x$$ - искомый элемент.

```Левосторонний поиск``` - поиск такого наименьшего (т.е. самого левого) индекса $$i$$ что $$as[i] \geq x$$, где $$x$$ - искомый элемент. 

Алгоритм
-----

Псевдокод для левостороннего поиска рекомендуется посмотреть здесь - [ИТМО вики-конспекты: Целочисленный двоичный поиск](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA).

Обратите внимание что чтобы изменить левосторонний поиск на правосторонний достаточно поправить две вещи: знак сравнения элемента в середине с искомым и то какой индекс является ответом и возвращается в самом конце. 

Советы
-----

1) Подготовьте несколько **простых** тестов, затем отладьте вашу программу посмотрев как меняется диапазон поиска:

 - Выводя его через ```System.out.println("left=" + l + ", right=" + r);```
 - Отлаживая по шагам как было рассказано [раньше](/blogs/239/2018/school239_105_2018_2019/2019/03/21/Java-debug.html)
 
2) Если ваша программа работает очень долго на простом тесте, то вероятно она зависла, а точнее - цикл сужения диапазона поиска от раза к разу работает с одним и тем же диапазоном, т.е. диапазон перестал уменьшаться, и т.о. весь алгоритм обречен на вечные поиски.

Что тогда делать? То же что предложено выше - отладьте вашу программу. Посмотрите почему она сошлась в этот диапазон поиска, и почему он на очередной итерации не сужается а остается таким же. Вы можете это исследовать как выводя все важные переменные в консоль, так и воспользовавшись отладчиком.   

 